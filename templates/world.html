<!DOCTYPE html>
<html>
<head>
    <title>Turtle World - Correct Per-Instance Coloring</title>
    <style>
        body { margin: 0; background-color: #1a1a1a; }
        canvas { display: block; }
        .home-link { position: absolute; top: 10px; left: 10px; color: #00ff7f; text-decoration: none; font-family: monospace; }
    </style>
</head>
<body>
    <a href="/" class="home-link">Back to Control Panel</a>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let turtleInstancedMesh, blockInstancedMesh;
        
        const dummy = new THREE.Object3D();
        const color = new THREE.Color();

        // Set a high, safe limit for the number of instances
        const MAX_INSTANCES = 50000;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            scene.fog = new THREE.Fog(0x1a1a1a, 50, 200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // --- Lights are not needed for MeshBasicMaterial but good for helpers ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const gridHelper = new THREE.GridHelper(200, 200, 0x888888, 0x444444);
            scene.add(gridHelper);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            // --- InstancedMesh Setup ---

            // --- Turtles (Single Color) ---
            const turtleGeometry = new THREE.BoxGeometry(1, 1, 1);
            const turtleMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF });
            turtleInstancedMesh = new THREE.InstancedMesh(turtleGeometry, turtleMaterial, MAX_INSTANCES);
            scene.add(turtleInstancedMesh);

            // --- Blocks (Multiple Colors) ---
            const blockGeometry = new THREE.BoxGeometry(1, 1, 1);
            // This material is now set up to receive color data from a buffer attribute.
            const blockMaterial = new THREE.MeshBasicMaterial({
                vertexColors: true, 
                transparent: true, 
                opacity: 0.8 
            });
            blockInstancedMesh = new THREE.InstancedMesh(blockGeometry, blockMaterial, MAX_INSTANCES);
            scene.add(blockInstancedMesh);


            window.addEventListener('resize', onWindowResize, false);

            fetchWorldData();
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function fetchWorldData() {
            fetch('/world_data')
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response.json();
                })
                .then(data => {
                    updateTurtles(data.turtles || {});
                    updateBlocks(data.blocks || {});
                })
                .catch(e => console.error("Failed to fetch world data:", e));
            
             setTimeout(fetchWorldData, 5000); 
        }

        function updateBlocks(blocks) {
            const blockIds = Object.keys(blocks);
            const numInstances = Math.min(blockIds.length, MAX_INSTANCES);
            
            // Set the number of instances that should be rendered.
            blockInstancedMesh.count = numInstances;
            
            // If there are no blocks, no need to proceed.
            if (numInstances === 0) return;

            // **THE FIX:** Create a fresh array to hold the RGB values for each instance.
            const colorArray = new Float32Array(numInstances * 3);

            let i = 0;
            for (const id of blockIds) {
                if (i >= numInstances) break;
                const blockData = blocks[id];
                
                // 1. Update the position matrix for this instance.
                dummy.position.set(blockData.x, blockData.y, blockData.z);
                dummy.updateMatrix();
                blockInstancedMesh.setMatrixAt(i, dummy.matrix);
                
                // 2. Convert the hex color to RGB and place it in our color array.
                color.set(blockData.color || '#808080');
                color.toArray(colorArray, i * 3);
                
                i++;
            }

            // 3. Tell Three.js that the instance matrix data has changed.
            blockInstancedMesh.instanceMatrix.needsUpdate = true;

            // 4. Create a new buffer attribute from our color array and attach it to the geometry.
            // This is what the material uses to color each instance.
            blockInstancedMesh.geometry.setAttribute('color', new THREE.InstancedBufferAttribute(colorArray, 3));
        }

        function updateTurtles(turtles) {
            const turtleIds = Object.keys(turtles);
            const numInstances = Math.min(turtleIds.length, MAX_INSTANCES);

            turtleInstancedMesh.count = numInstances;
            if (numInstances === 0) return;

            let i = 0;
            for (const id of turtleIds) {
                 if (i >= numInstances) break;
                const turtleData = turtles[id].status;

                dummy.position.set(turtleData.x, turtleData.y, turtleData.z);
                dummy.updateMatrix();
                turtleInstancedMesh.setMatrixAt(i, dummy.matrix);

                i++;
            }

            turtleInstancedMesh.instanceMatrix.needsUpdate = true;
        }

        init();
    </script>
</body>
</html>